//#region lib/classes/BracketEntrant.d.ts
declare class BracketEntrant {
  entrantID: string;
  entrantTag: string;
  initialSeed: number;
  finalPlacement?: number;
  other: {
    [key: string]: any;
  };
  constructor(props: {
    entrantTag: string;
    other: {
      image: string;
      seed: number;
      misc: string;
      username: string;
      finalRank: number;
      groupId: string;
      email?: string;
      tournamentId: number;
      name: string;
      timestamps: {
        created_at: Date;
        updated_at: Date;
      };
      states: {
        active: boolean;
      };
    };
    initialSeed: number;
    finalPlacement: number;
    entrantID: string;
  });
  setSeed(seed: number): void;
  setName(name: string): void;
  setMetaData(data: {
    [key: string]: never;
  }): void;
}
//#endregion
//#region lib/@types/obf.d.ts
declare enum SetGameResult {
  Win = "win",
  Lose = "lose",
  Draw = "draw",
  Dq = "dq",
}
/** Object representing an entrant in the tournament. Every unique entrant which appears in a set should have a corresponding `Entrant` object in the `entrants` subfield of `Tournament`. */
interface IEntrant {
  /** Unique string ID corresponding to this entrant. This ID can be an autogenerated identifier, some form of the player's tag, or the player's tag itself, as long as it is guaranteed that no two different entrants share the same `entrantID`. Entrants in `Set` objects are referenced by this ID. This is a required field. */
  entrantID: string;
  /** String containing the entrant's ``tag; in other words, the name the entrant chooses when registering for the tournament, that appears in results, etc. */
  entrantTag: string;
  /** Integer representing the initial seeding of this entrant. Larger seeds are worse seeds; 1 is the best possible seed. */
  initialSeed: number;
  /** Integer representing the final placing of this entrant. */
  finalPlacement: number;
  /** List of personal data about players corresponding to this entrant (e.g. legal name, country, etc.). If this entrant corresponds to a single player, this will be a list of size one. If it is a team of several players, there will be one entry per player. */
  personalInformation: PersonalInformation[];
  /** Object that can be used to store any other relevant entrant-related information not covered by the previously mentioned fields. */
  other: any;
}
/** Object representing personal information (e.g. name, country) associated with an entrant. Subobject of `Entrant`. */
declare class PersonalInformation implements IPersonalInformation {
  /** String containing entrant's legal name. */
  name: string;
  /** String containing entrant's country. */
  country: string;
  /** String containing entrant's tag. Same as entrantTag if entrant is a single player. */
  tag: string;
  /** String containing prefix for entrant's tag. */
  prefix: string;
  /** Object that can be used to store any other relevant personal entrant-related information not covered by the previously mentioned fields. */
  other: any;
  constructor(data?: IPersonalInformation);
  init(_data?: any): void;
  static fromJS(data: any): PersonalInformation;
  toJSON(data?: any): any;
}
/** Object representing personal information (e.g. name, country) associated with an entrant. Subobject of `Entrant`. */
interface IPersonalInformation {
  /** String containing entrant's legal name. */
  name: string;
  /** String containing entrant's country. */
  country: string;
  /** String containing entrant's tag. Same as entrantTag if entrant is a single player. */
  tag: string;
  /** String containing prefix for entrant's tag. */
  prefix: string;
  /** Object that can be used to store any other relevant personal entrant-related information not covered by the previously mentioned fields. */
  other: any;
}
/** Object representing a single set of the tournament. */
interface ISet {
  /** String containing a unique identifier for this set (i.e. no two sets in the event's `sets` array should have the same setID). */
  setID: string;
  /** The entrantID of the first player in this match. */
  entrant1ID: string;
  /** The entrantID of the second player in this match. */
  entrant2ID: string;
  /** String representing the status of this set. If populated, must take one of the following values: 'completed' (if the set has finished), 'started' (if the set is currently in progress), or 'pending' (if the set has yet to start). */
  status: SetStatus;
  /** String representing the result of entrant 1 in this match. If populated, must equal either 'win', 'lose', 'draw', or 'dq'. In the case of 'dq', the player disqualified should be assigned the 'dq' result and the other player should be assigned the 'win' result. (If both players are disqualified, both should be assigned 'dq'). */
  entrant1Result: SetGameResult;
  /** String representing the result of entrant 2 in this match. If populated, must equal either 'win', 'lose', 'draw', or 'dq'. */
  entrant2Result: SetGameResult;
  /** Integer representing the score of entrant 1 in this match. */
  entrant1Score: number;
  /** Integer representing the score of entrant 2 in this match. */
  entrant2Score: number;
  /** The setID of the set that entrant 1 will play next. For a single-elim or double-elim tournament, setting this allows one for reconstruction of the original bracket. If entrant 1 does not play another set (e.g. they have won or are knocked out), do not set this field. */
  entrant1NextSetID: string;
  /** The setID of the set that entrant 2 will play next. For a double-elim tournament, setting this allows one for reconstruction of the original bracket. If entrant 2 does not play another set, do not set this field. */
  entrant2NextSetID: string;
  /** The setID of the set that entrant 1 played right before this set. If this is entrant 1's first set, do not set this field. */
  entrant1PrevSetID: string;
  /** The setID of the set that entrant 2 played right before this set. If this is entrant 2's first set, do not set this field. */
  entrant2PrevSetID: string;
  /** String representing format specific to this set (e.g. whether it was best of 3 or best of 5). */
  setFormat: string;
  /** String representing the `phase' of this specific set. It is up to the user's discretion to decide what precisely a phase means. For tournaments with multiple phases / levels (e.g. pools, top 64, top 8), it is convenient to record this information here. */
  phaseID: string;
  /** String representing the `round' in the bracket of this specific set (for example, "Winner's Round 1" or "Semifinals"). It is up to the user's discretion to decide what precisely a round means and how to record it. */
  roundID: string;
  /** Array of `Game` objects containing information about each game of this set. It is recommended (but not required) that this array records the games in chronological order. See the `Game` definition for more information. */
  games: Game[];
  /** Object that can be used to store any other relevant set-related information not covered by the previously mentioned fields. */
  other: any;
}
/** Object representing a single game of a set. */
declare class Game implements IGame {
  /** Integer representing the number (in chronological order) of this game. The `gameNumber`s of the games of a set should be unique and span a consecutive range of integers starting at 1. */
  gameNumber: number;
  /** Array of strings representing the character(s) played by entrant 1 in this game. If entrant 1 only plays a single character in this game (most cases), this field should contain an array containing a single string (entrant 1's character). In team games or games where each entrant can choose a selection of different characters, you should record these characters as separate elements of this field. */
  entrant1Characters: string[];
  /** Array of strings representing the character(s) played by entrant 2 in this game. See also `entrant1Characters`. */
  entrant2Characters: any[];
  /** String representing the stage this game was played on. */
  stage: string;
  /** String representing the result of entrant 1. */
  entrant1Result: SetGameResult;
  /** String representing the result of entrant 2. */
  entrant2Result: SetGameResult;
  /** Object that can be used to store any other relevant game-related information not covered by the previously mentioned fields. */
  other: any;
  constructor(data?: IGame);
  init(_data?: any): void;
  static fromJS(data: any): Game;
  toJSON(data?: any): any;
}
/** Object representing a single game of a set. */
interface IGame {
  /** Integer representing the number (in chronological order) of this game. The `gameNumber`s of the games of a set should be unique and span a consecutive range of integers starting at 1. */
  gameNumber: number;
  /** Array of strings representing the character(s) played by entrant 1 in this game. If entrant 1 only plays a single character in this game (most cases), this field should contain an array containing a single string (entrant 1's character). In team games or games where each entrant can choose a selection of different characters, you should record these characters as separate elements of this field. */
  entrant1Characters: string[];
  /** Array of strings representing the character(s) played by entrant 2 in this game. See also `entrant1Characters`. */
  entrant2Characters: any[];
  /** String representing the stage this game was played on. */
  stage: string;
  /** String representing the result of entrant 1. */
  entrant1Result: SetGameResult;
  /** String representing the result of entrant 2. */
  entrant2Result: SetGameResult;
  /** Object that can be used to store any other relevant game-related information not covered by the previously mentioned fields. */
  other: any;
}
declare enum SetStatus {
  Completed = "completed",
  Started = "started",
  Pending = "pending",
}
//#endregion
//#region lib/classes/BracketSet.d.ts
declare class BracketSet {
  setId: number;
  uuid?: number | string;
  self: BracketSet;
  leftEntrant: BracketEntrant | undefined;
  rightEntrant: BracketEntrant | undefined;
  entrant1Result?: SetGameResult;
  entrant2Result?: SetGameResult;
  entrant1Score: number;
  entrant2Score: number;
  entrant1Ready: boolean;
  entrant2Ready: boolean;
  entrant1Reported: boolean;
  entrant2Reported: boolean;
  leftSet: BracketSet | undefined;
  rightSet: BracketSet | undefined;
  parentSet: BracketSet | undefined;
  leftWinnerSet: BracketSet | undefined;
  rightWinnerSet: BracketSet | undefined;
  loserSet: BracketSet | undefined;
  round: number;
  numberToWin: number;
  status: "started" | "pending" | "completed";
  type: "winners" | "losers";
  startTime: Date | undefined;
  endTime: Date | undefined;
  onStream: boolean;
  winner: string;
  loser: string;
  placement: number;
  other: {
    [key: string]: never;
  };
  constructor(props: {
    setId: number;
    uuid?: number;
    leftSet?: BracketSet;
    rightSet?: BracketSet;
    leftEntrant?: BracketEntrant;
    rightEntrant?: BracketEntrant;
    parentSet?: BracketSet;
    leftWinner?: BracketSet;
    rightWinner?: BracketSet;
    loserSet?: BracketSet;
    round: number;
    type?: "winners" | "losers";
    status?: "started" | "completed" | "pending";
    placement?: number;
    numberToWin?: number;
    other?: {
      [key: string]: never;
    };
  });
  isLeftChild(): boolean;
  isRightChild(): boolean;
  isLeftWinner(): boolean;
  isRightWinner(): boolean;
  isOnlyChild(): boolean;
  getPlacement(placement?: number, node?: BracketSet): number;
  getSibling(): BracketSet | undefined;
  addSet(node: BracketSet | undefined): void;
  addLeftSet(set: BracketSet | undefined): void;
  addRightSet(set: BracketSet | undefined): void;
  setLosersSet(losersSet: BracketSet | undefined): void;
  setLeftEntrant(entrant: BracketEntrant | undefined): void;
  setRightEntrant(entrant: BracketEntrant | undefined): void;
  setEntrant(entrant: BracketEntrant | undefined): void;
  setParentSet(parent: BracketSet): void;
  setMetaData(data: {
    [key: string]: never;
  }): void;
  updateScore(isP1: boolean, score: number): void;
}
//#endregion
//#region lib/classes/BracketEvent.d.ts
declare class BracketEvent {
  id?: string;
  numberOfEntrants: number;
  root: BracketSet;
  state: string;
  winnersRoot?: BracketSet;
  losersRoot?: BracketSet;
  extraRoot?: BracketSet;
  entrants: Array<BracketEntrant>;
  sets: Array<BracketSet>;
  layout: string;
  other?: {
    [key: string]: any;
  };
  constructor(props: {
    id?: string;
    sets?: ISet[];
    entrants: IEntrant[];
    layout: string;
    metaData?: {
      [key: string]: any;
    };
    state?: string;
  });
  mapSets(importedSets: ISet[]): void;
  createEntrants(entrants: IEntrant[]): BracketEntrant[];
  exportSets(): ISet[];
  assignEntrants(): void;
  createBracket(size?: number): BracketSet;
  orderSeeds(): number[][];
  weaveEntrants(): (BracketEntrant | undefined)[];
  attachLosersBracket(winnersFinals: BracketSet): BracketSet;
  linkLosersSets(losersBracket: BracketSet[]): BracketSet;
  createLosersBracket(winnersFinals: BracketSet): BracketSet;
  getAllWinnersSets(): BracketSet[];
  getAllLosersSets(): BracketSet[];
  getSetsByRound(round: number, filters?: {
    set?: BracketSet;
    type?: "winners" | "losers";
  }): BracketSet[];
  calculateRounds(size?: number): number;
  findHighestPowerOf2(threshold?: number): number;
  isPowerOf2(x: number): boolean;
  addMetaData(data: {
    [key: string]: any;
  }): void;
}
//#endregion
export { BracketEntrant, BracketEvent, BracketSet };